<!doctype html>
<html>
    <head>
        <title>threejs - trackball control</title>
        <style>
            
        </style>
    </head>
    <body>

        <div id="container"></div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
        <script>

        var screen = {
                width  : 400,
                height : 300
            },
            view = {
                angle  : 45,
                aspect : screen.width / screen.height,
                near   : 0.1,
                far    : 10000
            },
            renderer = new THREE.WebGLRenderer(),
            camera   = new THREE.PerspectiveCamera( view.angle, view.aspect, view. near, view.far ),
            scene    = new THREE.Scene();
            
            container = document.getElementById('container');
        
        var 
            cube;
            
        var mouseDown = false;
        var rotateStartPoint = new THREE.Vector3(0, 0, 1);
        var rotateEndPoint = new THREE.Vector3(0, 0, 1);

        var curQuaternion;
        var windowHalfX = screen.width / 2;
        var windowHalfY = screen.height / 2;
        var rotationSpeed = 2;
        var lastMoveTimestamp,
            moveReleaseTimeDelta = 50;

        var startPoint = {
            x: 0,
            y: 0
        };

        var deltaX = 0,
            deltaY = 0;

        function setup(){        
            scene.add(camera);
            scene.add(new THREE.AxisHelper(20));
            camera.position.set(0,0,2);
            camera.lookAt(new THREE.Vector3(0,0,0));           
            renderer.setSize(screen.width, screen.height);
            container.appendChild(renderer.domElement); 
        }

        function init(){
            setup();

            var geometry = new THREE.BoxGeometry(1, 1, 1),
                material = new THREE.MeshBasicMaterial({ color : 0xFFFFFF, wireframe: true});
                
            cube = new THREE.Mesh( geometry, material );
            
            scene.add(cube);

            render();
        }

        function render(){
            requestAnimationFrame( render ); 
            renderer.render( scene, camera );

            if (!mouseDown){
                var drag = 0.95;
                var minDelta = 0.05;

                if (deltaX < -minDelta || deltaX > minDelta)
                {
                    deltaX *= drag;
                }
                else
                {
                    deltaX = 0;
                }

                if (deltaY < -minDelta || deltaY > minDelta)
                {
                    deltaY *= drag;
                }
                else
                {
                    deltaY = 0;
                }

                handleRotation();
            }
            

        }

        init();

        document.addEventListener('mousedown', onDocumentMouseDown, false);

        function onDocumentMouseDown(event){
            event.preventDefault();

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mouseup', onDocumentMouseUp, false);

            mouseDown = true;

            startPoint = {
                x: event.clientX,
                y: event.clientY
            };

            rotateStartPoint = rotateEndPoint = projectOnTrackball(0, 0);
        }            

        function onDocumentMouseMove(event){
            deltaX = event.x - startPoint.x;
            deltaY = event.y - startPoint.y;

            handleRotation();

            startPoint.x = event.x;
            startPoint.y = event.y;

            lastMoveTimestamp = new Date();
        }

        function onDocumentMouseUp(event){
            if (new Date().getTime() - lastMoveTimestamp.getTime() > moveReleaseTimeDelta){
                deltaX = event.x - startPoint.x;
                deltaY = event.y - startPoint.y;
            }

            mouseDown = false;

            document.removeEventListener('mousemove', onDocumentMouseMove, false);
            document.removeEventListener('mouseup', onDocumentMouseUp, false);
        }

        function projectOnTrackball(touchX, touchY){
            var mouseOnBall = new THREE.Vector3();

            mouseOnBall.set(
                clamp(touchX / windowHalfX, -1, 1), clamp(-touchY / windowHalfY, -1, 1),
                0.0
            );

            var length = mouseOnBall.length();

            if (length > 1.0)
            {
                mouseOnBall.normalize();
            }
            else
            {
                mouseOnBall.z = Math.sqrt(1.0 - length * length);
            }

            return mouseOnBall;
        }

        function rotateMatrix(rotateStart, rotateEnd){
            var axis = new THREE.Vector3(),
                quaternion = new THREE.Quaternion();

            var angle = Math.acos(rotateStart.dot(rotateEnd) / rotateStart.length() / rotateEnd.length());

            if (angle)
            {
                axis.crossVectors(rotateStart, rotateEnd).normalize();
                angle *= rotationSpeed;
                quaternion.setFromAxisAngle(axis, angle);
            }
            return quaternion;
        }

        function clamp(value, min, max){
            return Math.min(Math.max(value, min), max);
        }

       function handleRotation(){
            rotateEndPoint = projectOnTrackball(deltaX, deltaY);

            var rotateQuaternion = rotateMatrix(rotateStartPoint, rotateEndPoint);
            curQuaternion = cube.quaternion;
            curQuaternion.multiplyQuaternions(rotateQuaternion, curQuaternion);
            curQuaternion.normalize();
            cube.setRotationFromQuaternion(curQuaternion);

            rotateEndPoint = rotateStartPoint;
        };


            

        </script>
    </body>

</html>